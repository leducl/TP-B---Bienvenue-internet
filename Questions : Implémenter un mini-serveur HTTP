2.1 Serveur minimal - “Hello World”

1. Est-ce que votre client (navigateur, curl, telnet…) reçoit bien une réponse ? Quel contenu voyez-vous à l’écran ?
→ Oui, le client reçoit une réponse. À l’écran, on voit le texte "Hello World!" qui s’affiche.

2. Quelle est la structure exacte du message que vous renvoyez (statut, entêtes, ligne vide, corps) ?
→ D’abord on a la ligne de statut : HTTP/1.1 200 OK.
Ensuite les entêtes : Content-Type: text/plain, Content-Length: 12, Connection: close.
Puis une ligne vide pour dire "les entêtes sont finis".
Enfin le corps contient : Hello World!.

3. Que se passe-t-il si vous changez Content-Length: 12 en une autre valeur ?
→ Si on met une valeur plus petite, le client n’affiche qu’une partie du texte.
Si on met une valeur plus grande, le client peut attendre plus de données qui n’arrivent jamais.

4. Que se passe-t-il si vous omettez complètement cette ligne ?
→ Certains clients arrivent à afficher le texte (parfois en mode "chunked" ou lecture jusqu’à la fermeture de la connexion).
D’autres peuvent bloquer ou ne pas afficher car ils ne savent pas combien de données lire.

5. Que se passe-t-il si vous supprimez la ligne vide entre les entêtes et le message ? Le navigateur ou le client affiche-t-il encore quelque chose ?
→ Le client ne sait pas où commencent les données. Souvent, rien ne s’affiche ou un message d’erreur s’affiche. La ligne vide est obligatoire.

6. Le message s’affiche-t-il dans telnet ? Et dans curl ? Et dans un navigateur ? Pourquoi certains outils sont-ils plus stricts que d’autres ?
→ Dans telnet, on voit tout car telnet affiche les données brutes sans rien vérifier.
Dans curl, ça dépend : il est assez souple mais peut signaler des erreurs.
Le navigateur est le plus strict, il respecte bien le protocole HTTP et peut refuser d’afficher s’il manque des parties.

2.2 Serveur avec analyse du chemin

Quelle est la structure de la ligne de requête HTTP reçue côté serveur ? Quels sont les trois éléments que vous devez extraire ?
→ La ligne a trois parties : méthode (ex : GET), chemin (ex : /motd), version (ex : HTTP/1.1).

Que se passe-t-il si la ligne est mal formée (vide ou incomplète) ? Comment éviter une erreur dans votre code ?
→ Erreur de type ValueError. Il faut utiliser un try/except ou vérifier le nombre d’éléments.

Que contient exactement la variable chemin ? Est-ce toujours ce que l’utilisateur a tapé dans l’URL ?
→ Elle contient le chemin demandé (ex : /motd). Oui, c’est ce que l’utilisateur tape après le domaine.

Que fait votre serveur si la méthode reçue est autre que GET ?
→ Il ignore ou peut renvoyer une erreur 405 Method Not Allowed.

Que se passe-t-il si le chemin n’est pas reconnu ? Quel message retournez-vous ? Est-il lisible ?
→ Le serveur renvoie 404 Not Found. Par défaut, c’est lisible mais peut être amélioré.

Le message 404 Not Found est-il suffisant ? Pourriez-vous y ajouter un texte plus explicite ?
→ Oui, mais un message HTML plus clair serait mieux (ex : <h1>Page introuvable</h1>).

Est-ce que les chemins /motd, /motd/, et /motd?x=42 sont identiques ? Comment les différencier ou les normaliser ?
→ Non, ils sont différents. On peut les normaliser avec urlparse ou supprimer les / finaux.

Pour ajouter un chemin comme /bonjour, que faut-il modifier ? Est-ce facilement extensible ?
→ Ajouter une condition if. Peu extensible, une structure type dictionnaire serait mieux.

Que pourrait-il se passer si un utilisateur tape une URL comme /../../etc/passwd ? Pourquoi est-ce dangereux ?
→ Cela peut donner accès à des fichiers système (attaque path traversal). C’est une faille grave.

Traitez-vous le chemin comme une chaîne ou une ressource contrôlée ? Quelles protections ajouter ?
→ Actuellement comme une chaîne. Il faut valider le chemin et empêcher les accès non autorisés.

